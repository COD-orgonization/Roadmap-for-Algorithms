# Материалы

[Видео1 - деревья](https://www.youtube.com/watch?v=0BUX_PotA4c)

---


Дерево — это иерархическая структура данных, состоящая из узлов (вершин), связанных ребрами. Оно имеет корневой узел и каждый узел имеет ноль или более дочерних узлов. Узлы без дочерних элементов называются листьями.

---

# Объяснение для пятилетнего ребёнка:
Представь, что у тебя есть семья. Самый главный — это дедушка, он стоит в самом верху. Это **корень** дерева.

У дедушки есть двое детей — мама и дядя. Они висят на нём, как яблочки на ветке. Это **узлы**.

У мамы есть ты и твоя сестра. А у дяди — твой двоюродный брат. Вы все — тоже узлы, но вы самые младшие и у вас уже нет своих детей. Вы — **листочки**.

Вот и получилось **дерево**! Все держатся за ручки (это **рёбра**) и не падают. В компьютере так же хранят разные вещи, чтобы их было легко искать — как будто играют в прятки по правилам: кто меньше, прячется слева, кто больше — справа.

---

# Сложность основных операций (Big O)

|Операция|Средний случай (сбалансированное дерево)|Худший случай (вырожденное дерево)|
|---|---|---|
|**Поиск**|O(log n)|O(n)|
|**Вставка**|O(log n)|O(n)|
|**Удаление**|O(log n)|O(n)|
|**Обход (все узлы)**|O(n)|O(n)|

---

# Основные виды деревьев

1. **Бинарное дерево (Binary Tree):** Каждый узел имеет не более двух дочерних узлов (левый и правый).
2. **Бинарное дерево поиска (Binary Search Tree - BST):** Частный случай бинарного дерева, где для каждого узла:
    - Все узлы левого поддерева меньше корня.
    - Все узлы правого поддерева больше корня.

3. **Сбалансированные деревья (AVL, Красно-черное дерево):** BST с автоматической балансировкой для поддержания высоты ~O(log n), что гарантирует эффективность операций.

4. **Двоичная куча (Binary Heap):** Полное бинарное дерево, удовлетворяющее свойству кучи (min-heap или max-heap). Основа для алгоритма HeapSort и очередей с приоритетом.

5. **Префиксное дерево (Trie):** Дерево для хранения строк, где каждый узел представляет собой символ. Эффективно для задач автодополнения и поиска по префиксу.

---

# Пример кода на JavaScript

```
class Node {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

class BinarySearchTree {
    constructor() {
        this.root = null;
    }

    // Вставка нового значения
    insert(value) {
        const newNode = new Node(value);
        if (this.root === null) {
            this.root = newNode;
            return this;
        }
        let current = this.root;
        while (true) {
            if (value === current.value) return undefined;
            if (value < current.value) {
                if (current.left === null) {
                    current.left = newNode;
                    return this;
                }
                current = current.left;
            } else {
                if (current.right === null) {
                    current.right = newNode;
                    return this;
                }
                current = current.right;
            }
        }
    }

    // Поиск значения
    find(value) {
        if (this.root === null) return false;
        let current = this.root;
        while (current) {
            if (value === current.value) return current;
            current = value < current.value ? current.left : current.right;
        }
        return false;
    }
}
```

#### Пример использования
```
const bst = new BinarySearchTree();
bst.insert(10).insert(5).insert(15).insert(3).insert(7);
console.log(bst.find(7)); // Вернет узел со значением 7
console.log(bst.find(100)); // Вернет false
```